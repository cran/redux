        -:    0:Source:conversions.c
        -:    0:Graph:/home/rich/Documents/src/redux/src/conversions.gcno
        -:    0:Data:/home/rich/Documents/src/redux/src/conversions.gcda
        -:    0:Runs:9
        -:    1:#include "conversions.h"
        -:    2:
     2975:    3:SEXP redis_reply_to_sexp(redisReply* reply, bool error_throw) {
     2975:    4:  if (reply == NULL) {
    #####:    5:    error("Failure communicating with the Redis server");
        -:    6:  }
     2975:    7:  switch(reply->type) {
      283:    8:  case REDIS_REPLY_STATUS:
      283:    9:    return status_to_sexp(reply->str);
     1344:   10:  case REDIS_REPLY_STRING:
     1344:   11:    return raw_string_to_sexp(reply->str, reply->len);
      905:   12:  case REDIS_REPLY_INTEGER:
      905:   13:    return (reply->integer < INT_MAX ?
      907:   14:            ScalarInteger(reply->integer) :
        2:   15:            ScalarReal((double)reply->integer));
       24:   16:  case REDIS_REPLY_NIL:
       24:   17:    return R_NilValue;
      414:   18:  case REDIS_REPLY_ARRAY:
      414:   19:    return array_to_sexp(reply, error_throw);
        5:   20:  case REDIS_REPLY_ERROR:
        5:   21:    return reply_error(reply, error_throw);
    #####:   22:  default:
        -:   23:    // In theory we should do something based on error action here but
        -:   24:    // it's also not triggerable.
    #####:   25:    error("Unknown type [redux bug -- please report]"); // # nocov
        -:   26:  }
        -:   27:  return R_NilValue; // # nocov
        -:   28:}
        -:   29:
     1671:   30:SEXP redis_check_command(SEXP cmd) {
     1671:   31:  if (TYPEOF(cmd) == VECSXP) {
     1645:   32:    if (LENGTH(cmd) == 0) {
        1:   33:      error("argument list cannot be empty");
        -:   34:    }
     1644:   35:    int np = 0;
        -:   36:
        -:   37:    // First, flatten the list:
        -:   38:    SEXP el;
     6799:   39:    for (int i = 0; i < LENGTH(cmd); ++i) {
     5191:   40:      if (TYPEOF(VECTOR_ELT(cmd, i)) == VECSXP) {
       36:   41:        cmd = PROTECT(redis_flatten_command(cmd));
       36:   42:        np++;
       36:   43:        break;
        -:   44:      }
        -:   45:    }
        -:   46:
        -:   47:    // Special checking for the first element:
     1644:   48:    el = VECTOR_ELT(cmd, 0);
     1644:   49:    if (TYPEOF(el) != STRSXP || LENGTH(el) == 0) {
        2:   50:      error("Redis command must be a non-empty character");
        -:   51:    }
     1642:   52:    int dup = 0;
     6890:   53:    for (int i = 0; i < LENGTH(cmd); ++i) {
     5251:   54:      el = VECTOR_ELT(cmd, i);
        -:   55:      // Only STRSXP, RAWSXP and NILSXP will make it out of this loop
        -:   56:      // unscathed.
     5251:   57:      switch(TYPEOF(el)) {
        2:   58:      case LGLSXP:
        -:   59:        // Coerce logicals to ints, then to string so that TRUE -> "1"
        -:   60:        // and FALSE -> "0", rather than to "TRUE"/"FALSE".
        2:   61:        el = PROTECT(coerceVector(el, INTSXP));
        2:   62:        np++;
      340:   63:      case INTSXP:
        -:   64:      case REALSXP:
      340:   65:        el = PROTECT(coerceVector(el, STRSXP));
      340:   66:        np++;
        -:   67:        // We need to duplicate the given argument here because we're
        -:   68:        // going to modify the list in place.  However, if the
        -:   69:        // argument is not named (which will *often* the case) we can
        -:   70:        // skip the duplicate step too.  I'll need to make sure that
        -:   71:        // this works reasonably well in terms of upstream code.
      340:   72:        if (!dup) {
      271:   73:          if (MAYBE_REFERENCED(cmd)) {
      258:   74:            cmd = PROTECT(shallow_duplicate(cmd));
      258:   75:            np++;
        -:   76:          }
      271:   77:          dup = 1;
        -:   78:        }
      340:   79:        SET_VECTOR_ELT(cmd, i, el);
        -:   80:        // Safe to unprotect straight away because these bits are
        -:   81:        // members of the list which is an argument, so therefore
        -:   82:        // protected.
      340:   83:        break;
     4908:   84:      case STRSXP:
        -:   85:      case RAWSXP:
        -:   86:      case NILSXP:
     4908:   87:        continue;
        2:   88:      case VECSXP:
        2:   89:        error("Nested list element");
        1:   90:      default:
        -:   91:        // NOTE: Not recursive!
        1:   92:        error("Incompatible list element (element %d)", i + 1);
        -:   93:      }
        -:   94:    }
     1639:   95:    UNPROTECT(np);
     1639:   96:    return cmd;
       26:   97:  } else if (TYPEOF(cmd) == STRSXP) {
        -:   98:    // Note, this *has* to be STRSXP (if not VECSXP) because of the
        -:   99:    // conversion that a command like "GET" would have on the rest of an
        -:  100:    // atomic vector.
       24:  101:    if (LENGTH(cmd) == 0) {
        1:  102:      error("Redis command must be a non-empty character");
        -:  103:    }
       23:  104:    SEXP ret = PROTECT(allocVector(VECSXP, 1));
       23:  105:    SET_VECTOR_ELT(ret, 0, cmd);
       23:  106:    UNPROTECT(1);
       23:  107:    return ret;
        -:  108:  } else {
        2:  109:    error("Invalid type");
        -:  110:  }
        -:  111:  return R_NilValue;
        -:  112:}
        -:  113:
       38:  114:SEXP redis_flatten_command(SEXP list) {
       38:  115:  const int len_in = LENGTH(list);
       38:  116:  int len_out = 0;
        -:  117:  SEXP el;
      179:  118:  for (int i = 0; i < len_in; ++i) {
      141:  119:    el = VECTOR_ELT(list, i);
      141:  120:    switch(TYPEOF(el)) {
       39:  121:    case VECSXP:
       39:  122:      len_out += LENGTH(el);
       39:  123:      break;
       68:  124:    case LGLSXP:
        -:  125:    case INTSXP:
        -:  126:    case REALSXP:
        -:  127:    case STRSXP:
        -:  128:    case RAWSXP:
       68:  129:      len_out++;
       68:  130:      break;
        -:  131:      // Don't allocate space for NULL values here.  TODO: check that
        -:  132:      // this is all OK
       34:  133:    case NILSXP:
       34:  134:      break;
    #####:  135:    default:
    #####:  136:      error("unexpected type (element %d)", i); // # nocov
        -:  137:    }
        -:  138:  }
       38:  139:  SEXP ret = PROTECT(allocVector(VECSXP, len_out));
      179:  140:  for (int i = 0, j = 0; i < len_in; ++i) {
      141:  141:    el = VECTOR_ELT(list, i);
      141:  142:    const int type_el = TYPEOF(el);
      141:  143:    if (type_el == VECSXP) {
      153:  144:      for (int k = 0; k < LENGTH(el); ++k) {
      114:  145:        SET_VECTOR_ELT(ret, j++, VECTOR_ELT(el, k));
        -:  146:      }
      102:  147:    } else if (type_el != NILSXP) { // STRSXP, RAWSXP
       68:  148:      SET_VECTOR_ELT(ret, j++, el);
        -:  149:    } // skips over NULL
        -:  150:  }
        -:  151:
       38:  152:  UNPROTECT(1);
       38:  153:  return ret;
        -:  154:}
        -:  155:
        4:  156:SEXP redis_check_list(SEXP list) {
        4:  157:  SEXP ret = PROTECT(shallow_duplicate(list));
       13:  158:  for (int i = 0; i < LENGTH(list); ++i) {
        9:  159:    SET_VECTOR_ELT(ret, i, redis_check_command(VECTOR_ELT(list, i)));
        -:  160:  }
        4:  161:  UNPROTECT(1);
        4:  162:  return ret;
        -:  163:}
        -:  164:
        -:  165:/* NOTE: We assume that the command has been passed through
        -:  166:   `redis_check_command` and operate with that assumption in mind */
     1654:  167:size_t sexp_to_redis(SEXP cmd, const char ***p_argv, size_t **p_argvlen) {
     1654:  168:  size_t argc = 0;
     6902:  169:  for (int i = 0; i < LENGTH(cmd); ++i) {
     5248:  170:    SEXP el = VECTOR_ELT(cmd, i);
     5248:  171:    const int type_el = TYPEOF(el);
     5248:  172:    argc += type_el == STRSXP ? LENGTH(el) : type_el == NILSXP ? 0 : 1;
        -:  173:  }
        -:  174:
     1654:  175:  const char **argv = (const char**) R_alloc(argc, sizeof(const char*));
     1654:  176:  size_t *argvlen = (size_t*) R_alloc(argc, sizeof(size_t));
     1654:  177:  size_t k = 0;
     6902:  178:  for (int i = 0; i < LENGTH(cmd); ++i) {
     5248:  179:    SEXP cmd_i = VECTOR_ELT(cmd, i);
     5248:  180:    int type_i = TYPEOF(cmd_i);
     5248:  181:    if (type_i == STRSXP) {
     9329:  182:      for (int j = 0; j < LENGTH(cmd_i); ++j, ++k) {
     5070:  183:        argv[k] = CHAR(STRING_ELT(cmd_i, j));
     5070:  184:        argvlen[k] = LENGTH(STRING_ELT(cmd_i, j));
        -:  185:      }
      989:  186:    } else if (type_i == RAWSXP) {
       84:  187:      argv[k] = (char *)RAW(cmd_i);
       84:  188:      argvlen[k] = LENGTH(cmd_i);
       84:  189:      k++;
      905:  190:    } else if (type_i != NILSXP) {
    #####:  191:      error("Unexpected type (2) [redux bug -- please report]"); // # nocov
        -:  192:    }
        -:  193:  }
        -:  194:
     1654:  195:  *p_argv = argv;
     1654:  196:  *p_argvlen = argvlen;
     1654:  197:  return argc;
        -:  198:}
        -:  199:
        -:  200:// I don't know that 'X\n' is going to be enough to *really* store
        -:  201:// this as binary data, but perhaps it will be enough.  If I don't
        -:  202:// want interoperability with RcppRedis I could pad that with more
        -:  203:// information and strip it off.  For now this will do.
        -:  204://
        -:  205:// I think I'll add my own thing and that allows storing of
        -:  206:// *arbitrary* binary data.  Perhaps add a separate 2 byte header?
        -:  207://
        -:  208:// This idea could be expanded to allow a flag to indicate if the
        -:  209:// data should be serialised/deserialised automatically.
        -:  210://
        -:  211:// Another thing worth checking here is for the existence of a null
        -:  212:// byte.  Empirically this turns up as character three in an R
        -:  213:// serialised string.
     1344:  214:bool is_raw_string(const char* str, size_t len) {
     1344:  215:  if (len > 2) {
     1042:  216:    if ((str[0] == 'X' || str[0] == 'B') && str[1] == '\n') {
      138:  217:      for (size_t i = 0; i < len; ++i) {
      136:  218:        if (str[i] == '\0') {
       36:  219:          return true;
        -:  220:        }
        -:  221:      }
        -:  222:    }
        -:  223:  }
     1308:  224:  return false;
        -:  225:}
        -:  226:
     1344:  227:SEXP raw_string_to_sexp(const char* str, size_t len) {
        -:  228:  // There are different approaches here to detecting a raw string; we
        -:  229:  // can test for presence of a nul byte, but that involves a
        -:  230:  // traversal of _every_ string.  It really should be corect though
        -:  231:  // as every serialisation header will contain a nul byte.
        -:  232:  //
        -:  233:  // The strategy here is to check for a serialised object, then
        -:  234:  // assume a string, but fall back on re-encoding as RAW (with an
        -:  235:  // extra copy) if a nul byte is found
     1344:  236:  bool is_raw = is_raw_string(str, len);
        -:  237:  SEXP ret;
     1344:  238:  if (is_raw) {
       36:  239:    ret = PROTECT(allocVector(RAWSXP, len));
       36:  240:    memcpy(RAW(ret), str, len);
       36:  241:    UNPROTECT(1);
        -:  242:  } else {
     1308:  243:    ret = PROTECT(mkString(str));
     1308:  244:    const size_t slen = LENGTH(STRING_ELT(ret, 0));
     1308:  245:    if (slen < len) {
        5:  246:      ret = PROTECT(allocVector(RAWSXP, len));
        5:  247:      memcpy(RAW(ret), str, len);
        5:  248:      UNPROTECT(2);
        -:  249:    } else {
     1303:  250:      UNPROTECT(1);
        -:  251:    }
        -:  252:  }
     1344:  253:  return ret;
        -:  254:}
        -:  255:
      283:  256:SEXP status_to_sexp(const char* str) {
      283:  257:  SEXP ret = PROTECT(mkString(str));
      283:  258:  setAttrib(ret, R_ClassSymbol, mkString("redis_status"));
      283:  259:  UNPROTECT(1);
      283:  260:  return ret;
        -:  261:}
        -:  262:
      414:  263:SEXP array_to_sexp(redisReply* reply, bool error_throw) {
      414:  264:  SEXP ret = PROTECT(allocVector(VECSXP, reply->elements));
        -:  265:  size_t i;
     1682:  266:  for (i = 0; i < reply->elements; ++i) {
     1268:  267:    SET_VECTOR_ELT(ret, i,
     1268:  268:                   redis_reply_to_sexp(reply->element[i], error_throw));
        -:  269:  }
      414:  270:  UNPROTECT(1);
      414:  271:  return ret;
        -:  272:}
        -:  273:
        5:  274:SEXP reply_error(redisReply* reply, bool error_throw) {
        5:  275:  SEXP ret = NULL;
        5:  276:  if (error_throw) {
        4:  277:    char * msg = (char*) R_alloc(reply->len + 1, sizeof(const char));
        4:  278:    memcpy(msg, reply->str, reply->len);
        4:  279:    msg[reply->len] = '\0';
        4:  280:    freeReplyObject(reply);
        4:  281:    error(msg);
        -:  282:    return ret;
        -:  283:  } else { // pass error back as object
        1:  284:    SEXP ret = PROTECT(mkString(reply->str));
        1:  285:    setAttrib(ret, R_ClassSymbol, mkString("redis_error"));
        1:  286:    UNPROTECT(1);
        1:  287:    return ret;
        -:  288:  }
        -:  289:}
