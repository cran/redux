        -:    0:Source:connection.c
        -:    0:Graph:/home/rich/Documents/src/redux/src/connection.gcno
        -:    0:Data:/home/rich/Documents/src/redux/src/connection.gcda
        -:    0:Runs:9
        -:    1:#include "connection.h"
        -:    2:#include "conversions.h"
        -:    3:
        -:    4:static void redis_finalize(SEXP extPtr);
        -:    5:char * string_duplicate(const char * x);
        -:    6:
        -:    7:// API functions first:
      361:    8:SEXP redux_redis_connect(SEXP r_host, SEXP r_port, SEXP r_timeout) {
        -:    9:  redisContext *context;
      361:   10:  const char * host = CHAR(STRING_ELT(r_host, 0));
      361:   11:  const int port = INTEGER(r_port)[0];
      361:   12:  if (LENGTH(r_timeout) == 0) {
      360:   13:    context = redisConnect(host, port);
        -:   14:  } else {
        1:   15:    int timeout = INTEGER(r_timeout)[0];
        1:   16:    struct timeval tvout = {timeout / 1000, (timeout % 1000) * 1000};
        1:   17:    context = redisConnectWithTimeout(host, port, tvout);
        -:   18:  }
      361:   19:  if (context == NULL) {
    #####:   20:    error("Creating context failed catastrophically [tcp]"); // # nocov
        -:   21:  }
      361:   22:  if (context->err != 0) {
        2:   23:    const char * errstr = string_duplicate(context->errstr);
        2:   24:    redisFree(context);
        2:   25:    error("Failed to create context: %s", errstr);
        -:   26:  }
      359:   27:  SEXP extPtr = PROTECT(R_MakeExternalPtr(context, r_host, R_NilValue));
      359:   28:  R_RegisterCFinalizer(extPtr, redis_finalize);
      359:   29:  UNPROTECT(1);
      359:   30:  return extPtr;
        -:   31:}
        -:   32:
        1:   33:SEXP redux_redis_connect_unix(SEXP r_path, SEXP r_timeout) {
        -:   34:  redisContext *context;
        1:   35:  const char * path = CHAR(STRING_ELT(r_path, 0));
        1:   36:  if (LENGTH(r_timeout) == 0) {
        1:   37:    context = redisConnectUnix(path);
        -:   38:  } else {
    #####:   39:    int timeout = INTEGER(r_timeout)[0];
    #####:   40:    struct timeval tvout = {timeout / 1000, (timeout % 1000) * 1000};
    #####:   41:    context = redisConnectUnixWithTimeout(path, tvout);
        -:   42:  }
        1:   43:  if (context == NULL) {
    #####:   44:    error("Creating context failed catastrophically [unix]"); // # nocov
        -:   45:  }
        1:   46:  if (context->err != 0) {
        1:   47:    const char * errstr = string_duplicate(context->errstr);
        1:   48:    redisFree(context);
        1:   49:    error("Failed to create context: %s", errstr);
        -:   50:  }
    #####:   51:  SEXP extPtr = PROTECT(R_MakeExternalPtr(context, r_path, R_NilValue));
    #####:   52:  R_RegisterCFinalizer(extPtr, redis_finalize);
    #####:   53:  UNPROTECT(1);
    #####:   54:  return extPtr;
        -:   55:}
        -:   56:
     1652:   57:SEXP redux_redis_command(SEXP extPtr, SEXP cmd) {
     1652:   58:  redisContext *context = redis_get_context(extPtr, true);
        -:   59:
     1647:   60:  cmd = PROTECT(redis_check_command(cmd));
     1638:   61:  const char **argv = NULL;
     1638:   62:  size_t *argvlen = NULL;
     1638:   63:  const size_t argc = sexp_to_redis(cmd, &argv, &argvlen);
        -:   64:
     1638:   65:  redisReply *reply = redisCommandArgv(context, argc, argv, argvlen);
     1638:   66:  SEXP ret = PROTECT(redis_reply_to_sexp(reply, true));
     1634:   67:  freeReplyObject(reply);
     1634:   68:  UNPROTECT(2);
     1634:   69:  return ret;
        -:   70:}
        -:   71:
        -:   72:// I don't think that append/get reply are safe from R because it's
        -:   73:// too easy to lock the process up.  So focus instead on a "pipline"
        -:   74:// operation that has some reasonable guarantees about R errors.
        4:   75:SEXP redux_redis_pipeline(SEXP extPtr, SEXP list) {
        4:   76:  redisContext *context = redis_get_context(extPtr, true);
        -:   77:
        -:   78:  // Now, try and do the basic processing of *all* commands before
        -:   79:  // sending any.
        4:   80:  list = PROTECT(redis_check_list(list));
        4:   81:  const size_t nc = LENGTH(list);
        4:   82:  const char ***argv = (const char***) R_alloc(nc, sizeof(const char**));
        4:   83:  size_t **argvlen = (size_t**) R_alloc(nc, sizeof(size_t*));
        4:   84:  size_t *argc = (size_t*) R_alloc(nc, sizeof(size_t));
       13:   85:  for (size_t i = 0; i < nc; ++i) {
        9:   86:    argc[i] = sexp_to_redis(VECTOR_ELT(list, i), argv + i, argvlen + i);
        -:   87:  }
        -:   88:
       13:   89:  for (size_t i = 0; i < nc; ++i) {
        9:   90:    redisAppendCommandArgv(context, argc[i], argv[i], argvlen[i]);
        -:   91:  }
        -:   92:
        4:   93:  redisReply *reply = NULL;
        4:   94:  SEXP ret = PROTECT(allocVector(VECSXP, nc));
       13:   95:  for (size_t i = 0; i < nc; ++i) {
        9:   96:    redisGetReply(context, (void*)&reply);
        9:   97:    SET_VECTOR_ELT(ret, i, redis_reply_to_sexp(reply, false));
        9:   98:    freeReplyObject(reply);
        -:   99:  }
        4:  100:  UNPROTECT(2);
        4:  101:  return ret;
        -:  102:}
        -:  103:
        -:  104:// Internal functions:
     2007:  105:redisContext* redis_get_context(SEXP extPtr, bool closed_error) {
        -:  106:  // It is not possible here to be *generally* typesafe, short of
        -:  107:  // adding (and checking at every command) that we have an external
        -:  108:  // pointer to the correct type.  So cross fingers and hope for the
        -:  109:  // best which is what most packages do I believe.  We can, however,
        -:  110:  // check that we're getting a pointer from the correct sort of
        -:  111:  // thing, and that the pointer is not NULL.
     2007:  112:  void *context = NULL;
     2007:  113:  if (TYPEOF(extPtr) != EXTPTRSXP) {
        3:  114:    error("Expected an external pointer");
        -:  115:  }
     2004:  116:  context = (redisContext*) R_ExternalPtrAddr(extPtr);
     2004:  117:  if (!context && closed_error) {
        2:  118:    error("Context is not connected");
        -:  119:  }
     2002:  120:  return context;
        -:  121:}
        -:  122:
      337:  123:static void redis_finalize(SEXP extPtr) {
      337:  124:  redisContext *context = redis_get_context(extPtr, false);
      337:  125:  if (context) {
      337:  126:    redisFree(context);
      337:  127:    R_ClearExternalPtr(extPtr);
        -:  128:  }
      337:  129:}
        -:  130:
        3:  131:char * string_duplicate(const char * x) {
        3:  132:  const size_t n = strlen(x);
        3:  133:  char * ret = (char*) R_alloc(n + 1, sizeof(char));
        3:  134:  strcpy(ret, x);
        3:  135:  return ret;
        -:  136:}
